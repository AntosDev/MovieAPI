<h1>Simple Movie API using NestJS</h1>

<h2>To Run:</h2>
<h4>docker compose up and wait (it will take some time to run the db migrations</h4>
<h4>Enjoy!</h4>
<h3>Useful commands:</h3>
<ul>
    <li>
        <pre>npm run start:dev</pre> to start the project with hot reload
    </li>
    <li>
        <pre>npm run typeorm:run-migrations</pre> to run needed migrations
    </li>
    <li>
        <pre>npm run typeorm:generate-migration</pre> to create a migration after a change in the entities
    </li>
</ul>
<h2>What could've been added?</h2>
<ul>
    <li>Better Error Handling</li>
    <li>More granular e2es</li>
    <li>Customised authentication guards</li>
</ul>

<h2>Technology stack</h2>
<ul>
    <li>NestJS</li>
    <li>Docker</li>
    <li>Postgres</li>
    <li>TyperORM</li>
</ul>

<h2>Main Design and Functional Features</h2>
<ul>
    <li>Architecture Design: SOLID, DDD, Hexagonal</li>
    <li>Everything is Dockerised</li>
    <li>Authentication: JWT, generated through ('auth/login')</li>
    <li>APIs
        <ul>
            <li>GET ('/movies'): returns list of the authenticates user's movies</li>
            <li>POST('/movies'): using a provided title fetches a movie from omdAPI and saves it's data</li>
        </ul>
    </li>
    <li>Security: Authentication guards, password hashing using bcrypt</li>
    <li>Seperate .env files for docker and local</li>
    <li>...</li>
</ul>

<h2>How it was developed</h2>
<p>
    The process tried to adhere as much as possible to:
        - SOLID (especially Seperation of concerns and IoC), 
        - hexagonal architecture (dependencies are outwards) 
        - DDD maintaining a clean domain layer where the business rules are inforced and an in the application layer used use cases instead of services and seperated the persistance logic from the business logic
<p>
<pre>
    The source code contains:
        - main files containing docker files, cofigurations and .env
        - under src
            - external providers: implementation of wrapper around omdAPI (since we have IoC the module will use the interface and  not the actual implementation)
            - healthcheck: the hello world APIs generated by nest
            - modules:
                - userauths: (the authentication stuff, does not strictly follow DDD as there is no need)
                    - application: the local and JWT strategies (the implementations needed to validate credentials, generate tokens and
                    validate them; followed nestjs official documentation)
                    - domain: contains the entities used by the module
                    - infra:
                        - http: the auth controller containing the ('auth/login') api
                        - data-access: the user database entity the repository used to retrieve users
                    - mocks: the classes used by ject
                    - the module.ts which is linking it all together
                - movies: (this is the core module of the application and does adhere to tactical patterns of DDD)
                    - application: the orchetrator layer, is not persistance ignorant (as it connects with the repository but do so using IoC)
                        - providers: the interfaces of the external providers that the module's application needs to function, the implementation of which will be offered by the module.ts
                        - the use cases of the application, tahese are the main functionalities of the module, each complete of its own accord                    
                        - the use cases' spec files to run unit tests
                    - domain: the core entities of the movies module, responsible for ensuring business rules
                    - infra: everything not part of the core business of the module is sent to the edge of the hexagone!
                        - http: the movies controller containing the APIs
                            - dtos: cotaining the objects that will be shared with teh outside world
                        - data-access:
                            - repositories: responsible for the data logic and returning the aggregate root
                            - entities: the database entities (ORMs) that will be used to generate the database and access it
                    - mocks: the classes used by jest
                    - the module.ts which is linking it all together    
            tests: contains the e2e tests used to validate this application                           

    Steps(Gross-modo):
<ol>
    <li> Nest new movie-api with npm</li>
    <li><pre>uild project structure 
        - moudlar 
            - application containing the use cases 
            - domain containing the domain objects and logic 
            - infra: containing both http (controllers) and data-access (entities, repositories implementation)            
    </pre></li>
    <li> Added online movies provider, used explicit injection instead of injection by interface to respect hexagonal architecture</li>
    <li> Implemented movies domain functionality</li>
    <li> Added repository (no DB access yet)</li>
    <li> Link the above together orchastrated in the use case</li>
    <li> Implement authentication module (following nestjs official documentation)</li>
    <li> Add local and jwt guards</li>
    <li> Guard create movie APi by JWT token</li>
    <li> Create entities and install typeORM packages</li>
    <li> Create docker files for postgres    </li>
    <li> Create database from TypeORM to postgres docker</li>
    <li> Save created movie in DB</li>
    <li> Get authenticated user from context</li>
    <li> Implement business logic (only 5 movies for basic users)</li>
    <li> Implement get movies API fully</li>
    <li> Implement unit tests for movies use cases</li>
    <li> dockerise nestjs</li>
</ol>
</pre>